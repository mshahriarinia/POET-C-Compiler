include opt.pi
<trace target/>
<input to=target syntax="Cfront.code" from=("rose_dgemm.C")/>
<trace top_nest1,decl_top_nest1,nest1,nest3,nest2/>
<eval INSERT(nest1,target);
      decl_top_nest1 = "";
      top_nest1 = (decl_top_nest1 nest1);
      ModifyTraceHandle[trace=target](nest1,top_nest1)/>

<trace var_tile_nest1/>
<eval var_clnup_top_nest1 = top_nest1/>

<parameter bsize_nest1 type=(INT INT INT) default=(16 16 16) message="Blocking factor for loop nest nest1"/>
<parameter usize_nest2 type=1.._ default=16 message="Unroll factor for loop nest2"/>

<eval block_nest1 = DELAY{
         bdim_nest1 = (BlockDim#("k","k_bk",HEAD(bsize_nest1)) BlockDim#("j","j_bk",HEAD(TAIL(bsize_nest1))) BlockDim#("i","i_bk",HEAD(TAIL(TAIL(bsize_nest1)))));
         var_tile_nest1 = COPY(nest1);
         AppendDecl(IntegerType,(("i_bk" "j_bk" "k_bk")),decl_top_nest1);
         BlockLoops[factor=bdim_nest1;trace_innerNest=var_tile_nest1;trace_decl=decl_top_nest1](nest2[Nest.body],nest1)
      }/>

<eval unroll_nest2 = DELAY{
         UnrollLoops[factor=usize_nest2](nest2[Nest.body],nest2)
      }/>
<eval cleanup_nest1 = DELAY{
         CleanupBlockedNests[trace=top_nest1](var_clnup_top_nest1)
      }/>


<eval APPLY{block_nest1};
      APPLY{unroll_nest2};
      APPLY{cleanup_nest1}/>
<output from=(target) syntax=("Cfront.code")/>
